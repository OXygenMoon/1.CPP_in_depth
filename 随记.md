# 记录一些 C++ 的语法

## static

1. 隐藏:多文件编译时, 使用 `static` 可以保证修饰的变量和函数的局部性

2. 生命周期持久:在程序运行时初始化,且初始化一次

3. `static` 修饰的变量默认初始值为0 (静态数据区内存字节默认是0x00)

4. 修饰类内成员变量时, 类的所有对象共享同一份拷贝

5. 修饰类的成员函数时, 不接受 this 指针, 只能访问 `static` 的成员变量

6. `static` 修饰的成员变量先于对象存在, 因此需要在类外初始化

## const

1. 声明为只读, 且定义时需要初始化, 否则没有机会修改

2. 对于指针变量来说, 可以修饰为顶层 `const` 如 `int * const pa`, 也可以修饰为底层 `const` 如 `const int * pa` 或 `int const * pa`

3. 在函数形式参数中使用 `const` 修饰, 表示输入参数在函数体内不能修改

4. 在类的成员函数末尾使用 `const` 修饰, 表示该成员函数不能修改成员变量

5. 使用 `const` 修饰函数返回值, 可以使得返回的类型不会是左值

6. `const` 成员函数可以访问是否是 `const` 对象的任何成员变量, `non-const` 不可以访问 `const` 对象的任何成员变量

7. `const` 类型变量可以通过类型转换 `const_cast` 将 `const` 转换为 `non-const`

8. `top-const` 无法作为重载区分, 但是 `botton-const` 可以

```
void foo(const int *pa){
    cout << "const function : " << *pa << endl;
}

void foo(int * pa){
    cout << "non-const function : " << *pa << endl; 
}

int main(){
    
    int a = 10;
    int *pa = &a;
    const int * pb = &a;
    foo(pa);
    foo(pb);

    return 0;
}
```

## 指针 和 const

1. 引用在编译器看来, 等价于常指针 `int &b = a;` 等价于 `int * const b = &a;`

2. 引用的使用在编译器看来, 自动解引用 `b` 等价于 `*b`

## C++ 的三种传递方式

1. 值传递 : 内置类型建议, 大的对象传递时消耗大量时间和空间(传值)

2. 指针传递 : 将4B 或者 8B 的地址值传递(传值,传递的是地址值)

3. 引用传递 : 为地址起了别名(传地址)

效率来说, 引用和指针效率更高

## 内存池

内存池(Memory Pool) 是一种内存分配方式. 

传统的内存分配方式 : new / malloc() 存在缺点 : 申请的内存块的大小不定, 多次使用以后, 会出现大量的内存碎片, 导致内存块的使用效率降低.

内存池的做法是 : 在使用内存之前, 先申请分配一定数量的大小相等的内存块作为备用. 当有需求的时候, 从内存池中分出一部分内存块, 如果内存块不够再申请. 可以显著减少内存碎片, 提高内存分配效率.

### STL 中的内存池

allocate() 包装了 malloc(), 而 deallocate() 包装了 free().

一般一次申请 20 * 2 个, 用一半, 留一半.

1. 首先客户端会调用malloc()配置一定数量的区块（固定大小的内存块，通常为8的倍数），假设40个32bytes的区块，其中20个区块（一半）给程序实际使用，1个区块交出，另外19个处于维护状态。剩余20个（一半）留给内存池，此时一共有（20 * 32byte）
2. 客户端之后有有内存需求，想申请（20 * 64bytes）的空间，这时内存池只有（20 * 32bytes），就先将（10 * 64bytes)个区块返回，1个区块交出，另外9个处于维护状态，此时内存池空空如也
3. 接下来如果客户端还有内存需求，就必须再调用malloc()配置空间，此时新申请的区块数量会增加一个随着配置次数越来越大的附加量，同样一半提供程序使用，另一半留给内存池。申请内存的时候用永远是先看内存池有无剩余，有的话就用上，然后挂在0-15号某一条链表上，要不然就重新申请。
4. 如果整个堆的空间都不够了，就会在原先已经分配区块中寻找能满足当前需求的区块数量，能满足就返回，不能满足就向客户端报bad_alloc异常



